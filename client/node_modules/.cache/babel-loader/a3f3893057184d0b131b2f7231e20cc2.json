{"ast":null,"code":"// This file holds our state type, as well as any other types related to this Redux store.\n// Response object for GET /heroes\n// https://docs.opendota.com/#tag/heroes%2Fpaths%2F~1heroes%2Fget\n// This type is basically shorthand for `{ [key: string]: any }`. Feel free to replace `any` with\n// the expected return type of your API response.\n// Use `enum`s for better autocompletion of action type names. These will\n// be compiled away leaving only the final value in your compiled code.\n//\n// Define however naming conventions you'd like for your action types, but\n// personally, I use the `@@context/ACTION_TYPE` convention, to follow the convention\n// of Redux's `@@INIT` action.\nexport let HeroesActionTypes; // Declare state types with `readonly` modifier to get compile time immutability.\n// https://github.com/piotrwitek/react-redux-typescript-guide#state-with-type-level-immutability\n\n(function (HeroesActionTypes) {\n  HeroesActionTypes[\"FETCH_REQUEST\"] = \"@@heroes/FETCH_REQUEST\";\n  HeroesActionTypes[\"FETCH_SUCCESS\"] = \"@@heroes/FETCH_SUCCESS\";\n  HeroesActionTypes[\"FETCH_ERROR\"] = \"@@heroes/FETCH_ERROR\";\n  HeroesActionTypes[\"SELECT_HERO\"] = \"@@heroes/SELECT_HERO\";\n  HeroesActionTypes[\"SELECTED\"] = \"@@heroes/SELECTED\";\n})(HeroesActionTypes || (HeroesActionTypes = {}));","map":{"version":3,"sources":["/Users/jding/BitBucket/react-redux-typescript-example/src/store/heroes/types.ts"],"names":["HeroesActionTypes"],"mappings":"AAAA;AAEA;AACA;AAiCA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAYA,iBAAZ,C,CAQA;AACA;;WATYA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;AAAAA,EAAAA,iB;GAAAA,iB,KAAAA,iB","sourcesContent":["// This file holds our state type, as well as any other types related to this Redux store.\n\n// Response object for GET /heroes\n// https://docs.opendota.com/#tag/heroes%2Fpaths%2F~1heroes%2Fget\nexport interface Hero extends ApiResponse {\n  id: number\n  name: string\n  localized_name: string\n  primary_attr: string\n  attack_type: string\n  roles: string[]\n  img: string\n  icon: string\n  base_health: number\n  base_health_regen: number\n  base_mana: number\n  base_mana_regen: number\n  base_armor: number\n  base_mr: number\n  base_attack_min: number\n  base_attack_max: number\n  base_str: number\n  base_agi: number\n  base_int: number\n  str_gain: number\n  agi_gain: number\n  int_gain: number\n  attack_range: number\n  projectile_speed: number\n  attack_rate: number\n  move_speed: number\n  turn_rate: number\n  cm_enabled: boolean\n  legs: number\n}\n\n// This type is basically shorthand for `{ [key: string]: any }`. Feel free to replace `any` with\n// the expected return type of your API response.\nexport type ApiResponse = Record<string, any>\n\n// Use `enum`s for better autocompletion of action type names. These will\n// be compiled away leaving only the final value in your compiled code.\n//\n// Define however naming conventions you'd like for your action types, but\n// personally, I use the `@@context/ACTION_TYPE` convention, to follow the convention\n// of Redux's `@@INIT` action.\nexport enum HeroesActionTypes {\n  FETCH_REQUEST = '@@heroes/FETCH_REQUEST',\n  FETCH_SUCCESS = '@@heroes/FETCH_SUCCESS',\n  FETCH_ERROR = '@@heroes/FETCH_ERROR',\n  SELECT_HERO = '@@heroes/SELECT_HERO',\n  SELECTED = '@@heroes/SELECTED'\n}\n\n// Declare state types with `readonly` modifier to get compile time immutability.\n// https://github.com/piotrwitek/react-redux-typescript-guide#state-with-type-level-immutability\nexport interface HeroesState {\n  readonly loading: boolean\n  readonly data: Hero[]\n  readonly errors?: string\n}\n"]},"metadata":{},"sourceType":"module"}
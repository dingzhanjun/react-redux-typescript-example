{"ast":null,"code":"import { all, call, fork, put, takeEvery, takeLatest } from 'redux-saga/effects';\nimport { TeamsActionTypes } from './types';\nimport { fetchError, fetchSuccess, teamSelected } from './actions';\nimport { callApi } from '../../utils/api';\nconst API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'https://api.opendota.com';\n\nfunction* handleFetch() {\n  try {\n    // To call async functions, use redux-saga's `call()`.\n    const res = yield call(callApi, 'get', API_ENDPOINT, '/teams');\n\n    if (res.error) {\n      yield put(fetchError(res.error));\n    } else {\n      yield put(fetchSuccess(res));\n    }\n  } catch (err) {\n    if (err instanceof Error && err.stack) {\n      yield put(fetchError(err.stack));\n    } else {\n      yield put(fetchError('An unknown error occured.'));\n    }\n  }\n}\n\nfunction* handleSelect(action) {\n  try {\n    const detail = yield call(callApi, 'get', API_ENDPOINT, `/teams/${action.payload}`);\n    const players = yield call(callApi, 'get', API_ENDPOINT, `/teams/${action.payload}/players`);\n\n    if (detail.error || players.error) {\n      yield put(fetchError(detail.error || players.error));\n    } else {\n      yield put(teamSelected({\n        detail,\n        players\n      }));\n    }\n  } catch (err) {\n    if (err instanceof Error && err.stack) {\n      yield put(fetchError(err.stack));\n    } else {\n      yield put(fetchError('An unknown error occured.'));\n    }\n  }\n} // This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\n\n\nfunction* watchFetchRequest() {\n  yield takeEvery(TeamsActionTypes.FETCH_REQUEST, handleFetch);\n}\n\nfunction* watchSelectTeam() {\n  yield takeLatest(TeamsActionTypes.SELECT_TEAM, handleSelect);\n} // We can also use `fork()` here to split our saga into multiple watchers.\n\n\nfunction* heroesSaga() {\n  yield all([fork(watchFetchRequest), fork(watchSelectTeam)]);\n}\n\nexport default heroesSaga;","map":{"version":3,"sources":["/Users/jding/BitBucket/react-redux-typescript-example/src/store/teams/sagas.ts"],"names":["all","call","fork","put","takeEvery","takeLatest","TeamsActionTypes","fetchError","fetchSuccess","teamSelected","callApi","API_ENDPOINT","process","env","REACT_APP_API_ENDPOINT","handleFetch","res","error","err","Error","stack","handleSelect","action","detail","payload","players","watchFetchRequest","FETCH_REQUEST","watchSelectTeam","SELECT_TEAM","heroesSaga"],"mappings":"AAAA,SAASA,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+BC,SAA/B,EAA0CC,UAA1C,QAA4D,oBAA5D;AACA,SAASC,gBAAT,QAAiC,SAAjC;AACA,SAASC,UAAT,EAAqBC,YAArB,EAA+CC,YAA/C,QAAmE,WAAnE;AACA,SAASC,OAAT,QAAwB,iBAAxB;AAEA,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAR,CAAYC,sBAAZ,IAAsC,0BAA3D;;AAEA,UAAUC,WAAV,GAAwB;AACtB,MAAI;AACF;AACA,UAAMC,GAAG,GAAG,MAAMf,IAAI,CAACS,OAAD,EAAU,KAAV,EAAiBC,YAAjB,EAA+B,QAA/B,CAAtB;;AAEA,QAAIK,GAAG,CAACC,KAAR,EAAe;AACb,YAAMd,GAAG,CAACI,UAAU,CAACS,GAAG,CAACC,KAAL,CAAX,CAAT;AACD,KAFD,MAEO;AACL,YAAMd,GAAG,CAACK,YAAY,CAACQ,GAAD,CAAb,CAAT;AACD;AACF,GATD,CASE,OAAOE,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,KAAf,IAAwBD,GAAG,CAACE,KAAhC,EAAuC;AACrC,YAAMjB,GAAG,CAACI,UAAU,CAACW,GAAG,CAACE,KAAL,CAAX,CAAT;AACD,KAFD,MAEO;AACL,YAAMjB,GAAG,CAACI,UAAU,CAAC,2BAAD,CAAX,CAAT;AACD;AACF;AACF;;AAED,UAAUc,YAAV,CAAuBC,MAAvB,EAA8D;AAC5D,MAAI;AACF,UAAMC,MAAM,GAAG,MAAMtB,IAAI,CAACS,OAAD,EAAU,KAAV,EAAiBC,YAAjB,EAAgC,UAASW,MAAM,CAACE,OAAQ,EAAxD,CAAzB;AACA,UAAMC,OAAO,GAAG,MAAMxB,IAAI,CAACS,OAAD,EAAU,KAAV,EAAiBC,YAAjB,EAAgC,UAASW,MAAM,CAACE,OAAQ,UAAxD,CAA1B;;AAEA,QAAID,MAAM,CAACN,KAAP,IAAgBQ,OAAO,CAACR,KAA5B,EAAmC;AACjC,YAAMd,GAAG,CAACI,UAAU,CAACgB,MAAM,CAACN,KAAP,IAAgBQ,OAAO,CAACR,KAAzB,CAAX,CAAT;AACD,KAFD,MAEO;AACL,YAAMd,GAAG,CAACM,YAAY,CAAC;AAAEc,QAAAA,MAAF;AAAUE,QAAAA;AAAV,OAAD,CAAb,CAAT;AACD;AACF,GATD,CASE,OAAOP,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,KAAf,IAAwBD,GAAG,CAACE,KAAhC,EAAuC;AACrC,YAAMjB,GAAG,CAACI,UAAU,CAACW,GAAG,CAACE,KAAL,CAAX,CAAT;AACD,KAFD,MAEO;AACL,YAAMjB,GAAG,CAACI,UAAU,CAAC,2BAAD,CAAX,CAAT;AACD;AACF;AACF,C,CAED;AACA;;;AACA,UAAUmB,iBAAV,GAA8B;AAC5B,QAAMtB,SAAS,CAACE,gBAAgB,CAACqB,aAAlB,EAAiCZ,WAAjC,CAAf;AACD;;AAED,UAAUa,eAAV,GAA4B;AAC1B,QAAMvB,UAAU,CAACC,gBAAgB,CAACuB,WAAlB,EAA+BR,YAA/B,CAAhB;AACD,C,CAED;;;AACA,UAAUS,UAAV,GAAuB;AACrB,QAAM9B,GAAG,CAAC,CAACE,IAAI,CAACwB,iBAAD,CAAL,EAA0BxB,IAAI,CAAC0B,eAAD,CAA9B,CAAD,CAAT;AACD;;AAED,eAAeE,UAAf","sourcesContent":["import { all, call, fork, put, takeEvery, takeLatest } from 'redux-saga/effects';\nimport { TeamsActionTypes } from './types';\nimport { fetchError, fetchSuccess, selectTeam, teamSelected } from './actions';\nimport { callApi } from '../../utils/api';\n\nconst API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || 'https://api.opendota.com';\n\nfunction* handleFetch() {\n  try {\n    // To call async functions, use redux-saga's `call()`.\n    const res = yield call(callApi, 'get', API_ENDPOINT, '/teams');\n\n    if (res.error) {\n      yield put(fetchError(res.error));\n    } else {\n      yield put(fetchSuccess(res));\n    }\n  } catch (err) {\n    if (err instanceof Error && err.stack) {\n      yield put(fetchError(err.stack));\n    } else {\n      yield put(fetchError('An unknown error occured.'));\n    }\n  }\n}\n\nfunction* handleSelect(action: ReturnType<typeof selectTeam>) {\n  try {\n    const detail = yield call(callApi, 'get', API_ENDPOINT, `/teams/${action.payload}`);\n    const players = yield call(callApi, 'get', API_ENDPOINT, `/teams/${action.payload}/players`);\n\n    if (detail.error || players.error) {\n      yield put(fetchError(detail.error || players.error));\n    } else {\n      yield put(teamSelected({ detail, players }));\n    }\n  } catch (err) {\n    if (err instanceof Error && err.stack) {\n      yield put(fetchError(err.stack));\n    } else {\n      yield put(fetchError('An unknown error occured.'));\n    }\n  }\n}\n\n// This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\nfunction* watchFetchRequest() {\n  yield takeEvery(TeamsActionTypes.FETCH_REQUEST, handleFetch);\n}\n\nfunction* watchSelectTeam() {\n  yield takeLatest(TeamsActionTypes.SELECT_TEAM, handleSelect);\n}\n\n// We can also use `fork()` here to split our saga into multiple watchers.\nfunction* heroesSaga() {\n  yield all([fork(watchFetchRequest), fork(watchSelectTeam)]);\n}\n\nexport default heroesSaga;\n"]},"metadata":{},"sourceType":"module"}